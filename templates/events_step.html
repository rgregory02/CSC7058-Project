<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Events ‚Äî {{ bio_name }}</title>
  <link rel="stylesheet" href="/static/styles.css">
<style>
  :root{
    --content-max: 1240px;   /* widen canvas */
    --bg:#f6f8fc;
    --card:#ffffff;
    --muted:#64748b;
    --line:#e7e9f2;
    --brand:#2563eb;
    --brand-ink:#0b3ea8;
  }

  html,body{ height:100%; }
  body{
    background:var(--bg);
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Helvetica,Arial,sans-serif;
    padding:56px 32px;                  /* more outer breathing room */
    line-height:1.45;                   /* taller lines */
    font-size:15.5px;                   /* nudge up base size */
  }

  .box{
    background:var(--card);
    max-width:var(--content-max);       /* 1240px wide canvas */
    margin:auto;
    padding:36px 36px 28px;
    border-radius:16px;
    box-shadow:0 14px 40px rgba(20,32,60,.06);
  }

  h1{ margin:0 0 14px; letter-spacing:.2px; font-size:clamp(22px,2.2vw,28px); }
  h3{ margin:0 0 12px; }

  .subheading{ color:#0f172a; margin-bottom:18px; font-weight:600; }

  /* Two-column builder with generous gap and wider left pane */
  .grid{
    display:grid;
    grid-template-columns: minmax(640px, 2fr) 1fr;
    gap:28px;
    align-items:start;
  }
  @media (max-width: 1040px){
    .grid{ grid-template-columns: 1fr; }
  }

  .card{
    background:#fff;
    border:1px solid var(--line);
    border-radius:14px;
    padding:22px;
  }

  /* Right panel stays visible */
  .sticky{ position:sticky; top:18px; }

  .row{ display:flex; gap:12px; align-items:center; margin:10px 0; flex-wrap:wrap; }

  /* Step sections with extra padding */
  .step{
    border:1px solid var(--line);
    border-radius:14px;
    padding:16px 16px 12px;
    margin-bottom:16px;
    background:#fbfdff;
  }
  .step > .step-title{ font-weight:800; margin-bottom:6px; }
  .step small{ color:var(--muted); }

  select,input[type="text"],input[type="date"]{
    padding:11px 12px;
    border:1px solid #dfe3ee;
    border-radius:12px;
    background:#fff;
    min-height:42px;
  }
  select{ min-width:240px; }

  .btn{
    padding:12px 18px;
    border-radius:12px;
    border:0;
    cursor:pointer;
    font-weight:800;
    line-height:1;
    letter-spacing:.1px;
  }
  .btn.primary{ background:var(--brand); color:#fff; }
  .btn.primary:hover{ background:var(--brand-ink); }
  .btn.outline{
    background:#fff; color:var(--brand); border:1px solid var(--brand);
  }

  .small{ font-size:13px; color:var(--muted); }
  .muted{ color:var(--muted); }

  .event-row{
    border-left:5px solid #cfe0ff;
    background:#f4f8ff;
    border-radius:12px;
    padding:14px;
    margin:16px 0;
  }
  .event-row input[type="range"]{ height:6px; }

  .flash-container{ margin-bottom:12px; }
  .flash-banner{ padding:12px; border-radius:10px; }
  .flash-success{ background:#ecfdf5; color:#065f46; }
  .flash-error{ background:#fef2f2; color:#991b1b; }

  .helpdot{
    display:inline-block;width:18px;height:18px;border-radius:50%;
    background:#eef2ff;color:#374151;text-align:center;font:800 12px/18px system-ui;cursor:help;
  }

  /* Collapsible intro becomes a roomy hero */
  details.intro summary{
    cursor:pointer; font-weight:800; list-style:none;
  }
  details.intro{ border:1px dashed var(--line); border-radius:14px; padding:16px 18px; }
  details.intro[open]{ background:#fcfeff; }

  /* First-time hero CTA gets extra padding and width */
  .hero{
    max-width:900px;
    margin:18px auto 0;
    text-align:center;
    padding:26px 22px;
    border-radius:16px;
    border:1px solid var(--line);
    background:#ffffff;
  }
  .hero p{ margin:8px 0 0; }

  .hidden { display: none !important; }      

  .child-wrap { display: inline-flex; gap: 8px; align-items: center; }
</style>

<script>

  function prettyName(s){
    return (s || '')
      .trim()
      .replace(/[_-]+/g, ' ')
      .replace(/\b\w/g, m => m.toUpperCase());
  }
  // --- utilities ---
  function parseJSONFromScript(id){
    try{ return JSON.parse((document.getElementById(id)?.textContent) || '{}'); }
    catch(e){ return {}; }
  }
  async function fetchJSON(url){
    const res = await fetch(url);
    let data = {};
    try{ data = await res.json(); }catch(_){}
    if(!res.ok || data.ok === false) throw new Error(data.error || res.statusText);
    return data;
  }

  // Will be filled AFTER the payload <script> exists in the DOM.
  let TIME_OPTIONS_BY_KEY = {};
  let OPTIONS = [];

  // ---------- TIME UI (unchanged) ----------
  function wireTimeVisibility(row){
    const kindSel   = row.querySelector('select[name="row_time_kind[]"]');
    const dateBox   = row.querySelector('[data-time="date"]');
    const rangeBox  = row.querySelector('[data-time="range"]');
    const subBox    = row.querySelector('[data-time="sub"]');
    const labelBox  = row.querySelector('[data-time="label"]');
    const labelSel  = row.querySelector('select[name="row_time_label[]"]');
    const labelFree = row.querySelector('input[name="row_time_label_free[]"]');

    const update = () => {
      const k = (kindSel.value || '').trim();
      const hasFolder = !!TIME_OPTIONS_BY_KEY[k];

      // visibility
      dateBox.classList.toggle('hidden', k !== 'date');
      rangeBox.classList.toggle('hidden', k !== 'range');
      labelBox.classList.toggle('hidden', !hasFolder);
      // sub visible only when not date/range and no folder-backed labels
      subBox.classList.toggle('hidden', (k === '' || k === 'date' || k === 'range' || hasFolder));

      // populate labels for folder-backed kinds
      if (hasFolder && labelSel){
        const opts = TIME_OPTIONS_BY_KEY[k] || [];
        labelSel.innerHTML = '<option value="">‚Äî choose time label ‚Äî</option>' +
          opts.map(o => `<option value="${o.id}">${o.display}</option>`).join('');
      } else if (labelSel){
        labelSel.innerHTML = '';
      }

      // optional cleanup when hidden
      if (labelBox.classList.contains('hidden') && labelFree) labelFree.value = '';
      if (subBox.classList.contains('hidden')){
        const subIn = row.querySelector('input[name="row_time_subvalue[]"]');
        if (subIn) subIn.value = '';
      }
    };

    kindSel.addEventListener('change', update);
    update();
  }

  // Child option dropdown for some event options (unchanged)
  function refreshChildSelect(){
    const optSel = document.getElementById('option_id');
    const childWrap = document.getElementById('child_wrap');
    const childSel  = document.getElementById('child_option_id');
    childSel.innerHTML = '';
    childWrap.classList.add('hidden');

    if(!optSel) return;
    const id = optSel.value;
    const opt = OPTIONS.find(o => o.id === id);
    if(opt && Array.isArray(opt.children) && opt.children.length){
      childWrap.classList.remove('hidden');
      childSel.appendChild(new Option('‚Äî choose ‚Äî', ''));
      opt.children.forEach(c => {
        const label = c.label || c.display || c.id;
        childSel.appendChild(new Option(label, c.id));
      });
    }
  }

  // Returns the number of bios in a folder, recursively (includes descendants)
  async function getRecursiveCount(type, folderKey){
    const u = new URL('/api/bios/list', location.origin);
    u.searchParams.set('type', type);
    u.searchParams.set('recursive', '1');   // include descendants
    u.searchParams.set('limit', '100000');  // practical upper bound
    if (folderKey) u.searchParams.set('folder', folderKey);
    const { items = [] } = await fetchJSON(u.toString());
    return items.length;
  }

  async function loadFoldersFor(selectEl, type, parentKey){
    // Always start with a root entry
    selectEl.innerHTML = '<option value="">(root)</option>';
    try{
      const u = new URL('/api/bios/folders', location.origin);
      u.searchParams.set('type', type);
      if (parentKey) u.searchParams.set('parent', parentKey);

      // API returns: items: [{ name, label, key, count }]
      const { items = [] } = await fetchJSON(u.toString());

      const isTopLevel = !parentKey;

      if (isTopLevel){
        // For top-level, show TOTALS (including descendants)
        const totals = await Promise.all(items.map(i => getRecursiveCount(type, i.key)));
        items.forEach((i, idx) => {
          const nice = prettyName(i.label || i.name || i.key);
          const cnt  = totals[idx] || 0;
          selectEl.add(new Option(`${nice}${cnt ? ` (${cnt})` : ''}`, i.key));
        });
      } else {
        // For subfolders, direct counts are fine
        items.forEach(i => {
          const nice = prettyName(i.label || i.name || i.key);
          const cnt  = i.count || 0; // direct count (this level)
          selectEl.add(new Option(`${nice}${cnt ? ` (${cnt})` : ''}`, i.key));
        });
      }
    }catch(e){
      console.warn('[folders] load failed:', e.message);
      // keep just (root)
    }
  }

  async function loadBiosFor(selectEl, type, folderKey){
    selectEl.innerHTML = '<option value="">(none)</option>';
    try{
      const u = new URL('/api/bios/list', location.origin);
      u.searchParams.set('type', type);
      if (folderKey) u.searchParams.set('folder', folderKey);
      u.searchParams.set('recursive', '0');  // only this folder
      u.searchParams.set('limit', '1000');
      const {items=[]} = await fetchJSON(u.toString());
      items.forEach(it => {
        // prefer stable key when present
        const val = it.key || it.id;
        const name = it.name || it.id;
        selectEl.add(new Option(name, val));
      });
    }catch(e){
      console.warn('[bios] load failed:', e.message);
    }
  }

  function wireRowFolderPickers(row){
    const linkTypesTmpl = document.getElementById('linkTypeTemplate');
    const typeSel = row.querySelector('.link-type');
    const f1Sel   = row.querySelector('.folder-1');
    const f2Wrap  = row.querySelector('.folder2-wrap');
    const f2Sel   = row.querySelector('.folder-2');
    const bioSel  = row.querySelector('.link-target');

    // fill link types from template
    typeSel.innerHTML = Array.from(linkTypesTmpl.options)
      .map(o => `<option value="${o.value}">${o.text}</option>`).join('');

    async function refreshForType(){
      const t = (typeSel.value || '').trim();
      await loadFoldersFor(f1Sel, t, '');
      f2Wrap.classList.add('hidden');
      await loadBiosFor(bioSel, t, f1Sel.value || '');
    }
    async function refreshForParent(){
      const t = (typeSel.value || '').trim();
      await loadFoldersFor(f2Sel, t, f1Sel.value || '');
      const hasChildren = (f2Sel.options.length > 1);
      f2Wrap.classList.toggle('hidden', !hasChildren);
      const folderKey = hasChildren ? f2Sel.value : (f1Sel.value || '');
      await loadBiosFor(bioSel, t, folderKey);
    }
    async function refreshForChild(){
      const t = (typeSel.value || '').trim();
      await loadBiosFor(bioSel, t, (f2Sel.value || f1Sel.value || ''));
    }

    typeSel.addEventListener('change', refreshForType);
    f1Sel.addEventListener('change', refreshForParent);
    f2Sel.addEventListener('change', refreshForChild);

    // initial
    refreshForType();
  }

  // ---------- Build row & wire everything ----------
  function addRowFromSelected(){
    const optSel   = document.getElementById('option_id');
    const childSel = document.getElementById('child_option_id');
    const optId    = optSel?.value || '';
    if(!optId){ alert('Pick an option first.'); return; }
    const optText  = optSel?.options[optSel.selectedIndex]?.text || optId;

    const childShown = childSel && !childSel.closest('.hidden');
    const childId    = childShown ? (childSel.value || '') : '';
    const childText  = childShown ? (childSel.options[childSel.selectedIndex]?.text || childId) : '';

    const timeKindsTmpl = document.getElementById('timeKindsTemplate');

    const row  = document.createElement('div');
    row.className = 'event-row';
    row.innerHTML = `
      <div class="row">
        <strong style="min-width:120px">Option:</strong>
        <span>${optText}${childText ? ' ‚Üí ' + childText : ''}</span>
        <input type="hidden" name="row_option_id[]" value="${optId}">
        <input type="hidden" name="row_option_display[]" value="${(childText||optText)}">
        <input type="hidden" name="row_child_option_id[]" value="${childId}">
      </div>

      <div class="row">
        <label>Link type</label>
        <select name="row_link_type[]" class="link-type"></select>

        <label>Folder</label>
        <select name="row_link_folder1[]" class="folder-1"></select>

        <span class="child-wrap folder2-wrap hidden">
          <label>Subfolder</label>
          <select name="row_link_folder2[]" class="folder-2"></select>
        </span>

        <label>Target</label>
        <select name="row_link_bio[]" class="link-target"></select>

        <label>Confidence</label>
        <input type="range" name="row_confidence[]" min="0" max="100" value="100"
               oninput="this.nextElementSibling.textContent=this.value + '%'">
        <span class="small">100%</span>

        <button type="button" class="btn outline" onclick="this.closest('.event-row').remove()">Remove</button>
      </div>

      <div class="row">
        <strong>Time</strong>
        <select name="row_time_kind[]">
          ${Array.from(timeKindsTmpl.options).map(o => `<option value="${o.value}">${o.text}</option>`).join('')}
        </select>

        <span data-time="date" class="hidden">
          <input type="date" name="row_date_value[]" placeholder="YYYY-MM-DD">
        </span>

        <span data-time="range" class="hidden">
          <input type="text" name="row_start_date[]" placeholder="start (YYYY|YYYY-MM|YYYY-MM-DD)">
          <input type="text" name="row_end_date[]"   placeholder="end (optional)">
        </span>

        <span data-time="sub" class="hidden">
          <input type="text" name="row_time_subvalue[]" placeholder="e.g. toddler / WW2 / 1990s">
        </span>

        <span data-time="label" class="hidden" style="display:inline-flex; gap:8px; align-items:center;">
          <select name="row_time_label[]"></select>
          <input type="text" name="row_time_label_free[]" placeholder="or enter custom period">
        </span>

        <label>Conf</label>
        <input type="range" name="row_time_confidence[]" min="0" max="100" value="100"
               oninput="this.nextElementSibling.textContent=this.value + '%'">
        <span class="small">100%</span>
      </div>
    `;
    document.getElementById('rows').appendChild(row);

    // Wire folder-aware picker + time UI
    wireRowFolderPickers(row);
    wireTimeVisibility(row);
  }

  // ---- prevent auto-post; save only on explicit buttons ----
  function onGroupChange(sel){
    const params = new URLSearchParams(window.location.search);
    params.set('group_key', sel.value || '');
    params.set('start', '1');
    window.location.search = params.toString();
  }
  function markSaveIntent(val){
    const el = document.getElementById('do_save');
    if (el) el.value = val ? '1' : '';
  }
  function guardSubmit(e){
    const el = document.getElementById('do_save');
    if (!el || el.value !== '1'){
      e.preventDefault();
      return false;
    }
    return true;
  }

  document.addEventListener('DOMContentLoaded', () => {
    // Load payloads NOW that the script tags exist
    TIME_OPTIONS_BY_KEY = parseJSONFromScript('time_options_payload');
    OPTIONS = {{ (options or []) | tojson }};

    refreshChildSelect();
    document.getElementById('option_id')?.addEventListener('change', refreshChildSelect);
  });
</script>

</head>
<body>
<div class="box">

  {% with messages = get_flashed_messages(with_categories=true) %}
    {% if messages %}
      <div class="flash-container">
        {% for category, message in messages %}
          <div class="flash-banner flash-{{ category }}">{{ message }}</div>
        {% endfor %}
      </div>
    {% endif %}
  {% endwith %}

  <h1>üß© Events</h1>
  <div class="subheading">
    <strong>{{ bio_name }}</strong> ‚Ä¢ {{ type_name|replace('_',' ')|title }}
  </div>

  <!-- intro (collapsible) -->
<details class="intro card" style="max-width:1000px; margin:0 auto 12px;" open>
  <summary>What is an event?</summary>
  <div class="small" style="margin-top:8px">
    An event is something that happened to <strong>{{ bio_name }}</strong> ‚Äî e.g.
    <em>‚ÄúStarted job at St. Mary‚Äôs Hospital‚Äù</em> or <em>‚ÄúAdopted dog (Labrador)‚Äù</em>.
    Choose a <em>group</em> (category), an <em>option</em> (the thing),
    optionally a <em>child</em> detail, link a biography if relevant, and add a <em>time</em>.
    You can queue multiple rows then save together.
  </div>
  <div class="small" style="margin-top:6px">
    Tip: Use <strong>Save &amp; Add More</strong> to keep building, or
    <strong>Save Events &amp; Continue</strong> to move on.
  </div>
</details>

  <!-- payloads -->
  <script id="linkable_payload" type="application/json">{{ (linkable or {})|tojson }}</script>
  <script id="time_options_payload" type="application/json">{{ (time_options_by_key or {})|tojson }}</script>

  {% set has_events = (current_events|length) > 0 %}
  {% set start = show_builder %}

{% if not start and not has_events %}
  <section class="hero">
    <h3 style="margin-top:0;font-size:20px">Add your first event</h3>
    <p class="small">Choose a group, pick an option (and child if offered), then press <strong>+ Add Event Details</strong> to set link &amp; time.</p>
    <div style="margin-top:14px; display:flex; gap:10px; justify-content:center; flex-wrap:wrap;">
      <a class="btn primary" href="{{ url_for('general_step_events', type_name=type_name, bio_id=bio_id) }}?start=1">
        Start adding events
      </a>
      <a class="btn outline" target="_top"
         href="{{ url_for('general_iframe_wizard', type=type_name, bio_id=bio_id, step='review') }}">
        Skip to Review
      </a>
    </div>
  </section>
{% endif %}

  <div id="builder" style="{{ 'display:block' if (start or has_events) else 'display:none' }}">
    <div class="grid">
  <!-- Left: Builder -->
  <div class="card">
    <h3 style="margin-bottom:12px">Build Events</h3>

    <!-- Guard submit; only save buttons set do_save=1 -->
    <form method="POST" onsubmit="return guardSubmit(event)">
      <input type="hidden" name="do_save" id="do_save" value="">

      <!-- STEP 1 -->
      <div class="step">
        <div class="step-title">1) Choose a group</div>
        <div class="small muted" style="margin-bottom:8px">
          The group controls which options you can pick (e.g. Relationship, Role, Pet).
        </div>
        <div class="row">
          <label>Group <span class="helpdot" title="Event category. It determines which options you can pick.">?</span></label>
          <select id="group_key" name="group_key" onchange="onGroupChange(this)">
            {% for g in groups %}
              <option value="{{ g.key }}" {% if g.key==chosen_group %}selected{% endif %}>{{ g.label }}</option>
            {% endfor %}
          </select>
        </div>
      </div>

      <!-- STEP 2 -->
      <div class="step">
        <div class="step-title">2) Pick an option (and child if offered)</div>
        <div class="small muted" style="margin-bottom:8px">
          Some options expose a more specific <em>child</em> choice (e.g. Pet ‚Üí Labrador).
        </div>
        <div class="row">
          <label>Option <span class="helpdot" title="The specific event within the group. Some options expose a Child selector for finer detail.">?</span></label>
          <select id="option_id" name="option_id">
            <option value="">‚Äî choose ‚Äî</option>
            {% for o in (options or []) %}
              <option value="{{ o.id }}">{{ o.display or o.label or o.id }}</option>
            {% endfor %}
          </select>

<span id="child_wrap" class="child-wrap hidden">
  <label>Child <span class="helpdot" title="A more precise sub-choice for the option (e.g. pet ‚Üí labrador).">?</span></label>
  <select id="child_option_id" name="child_option_id"></select>
</span>

          <button type="button" class="btn outline" onclick="addRowFromSelected()">+ Add Event Details</button>
        </div>
        <div class="small muted" style="margin-top:-4px;">
          After <strong>+ Add Event Details</strong>, set link &amp; time for this event below.
        </div>
      </div>

      <!-- Hidden templates (unchanged) -->
      <select id="linkTypeTemplate" class="hidden">
        {% for t in allowed_types %}
          <option value="{{ t }}">{{ t|replace('_',' ')|title }}</option>
        {% endfor %}
      </select>

      <select id="timeKindsTemplate" class="hidden">
        <option value="">‚Äî none ‚Äî</option>
        {% for kind in time_kinds %}
          <option value="{{ kind.key }}">{{ kind.desc }}</option>
        {% endfor %}
      </select>

      <!-- STEP 3 -->
      <div class="step" style="background:#fff;">
        <div class="step-title">3) Link &amp; time each row</div>
        <div class="small muted" style="margin-bottom:8px">
          For each row, pick a link target (optional) and add time:
          a <em>date</em>, a <em>range</em>, a <em>folder-label</em> like ‚Äú1990s‚Äù, or free text.
        </div>

        <div id="rows"></div>

        <div style="display:flex; gap:10px; margin-top:12px;">
          <button type="submit" class="btn outline" name="next_action" value="stay"
                  onclick="markSaveIntent(true)">üíæ Save &amp; Add More</button>
          <button type="submit" class="btn primary" name="next_action" value="review"
                  onclick="markSaveIntent(true)">‚úÖ Save Events &amp; Continue</button>
        </div>
        <div class="small muted" style="margin-top:8px">
          Not ready to finish? Use <strong>Save &amp; Add More</strong> to keep building this entry.
          Happy with these rows? Choose <strong>Save Events &amp; Continue</strong>.
        </div>
      </div>
    </form>
  </div>

  <!-- Right: Summary (sticky) -->
  <div class="card sticky">
    <h3>Current Entry ‚Äî Events</h3>
    {% if current_events %}
      <ul class="small" style="margin:0 0 0 16px">
        {% for ev in current_events %}
          <li>
            <strong>{{ ev.option_display or ev.option_id }}</strong>
            {% if ev.link_type and ev.linked_bio %}
              ‚Äî <em>{{ ev.link_type }}</em> ‚Üí <code>{{ ev.linked_bio }}</code>
            {% endif %}
            {% if ev.time %}
              {% if ev.time.label_type=='date' %} ‚Ä¢ {{ ev.time.date_value }}
              {% elif ev.time.label_type=='range' %} ‚Ä¢ {{ ev.time.start_date }}‚Ä¶{{ ev.time.end_date }}
              {% elif ev.time.label_type=='sub' and ev.time.subvalue %} ‚Ä¢ {{ ev.time.subvalue|replace('_',' ')|title }}
              {% else %}
                {% if ev.time.label_id %} ‚Ä¢ {{ ev.time.label_id }}{% endif %}
                {% if ev.time.label_free %} ({{ ev.time.label_free }}){% endif %}
              {% endif %}
            {% endif %}
            {% if ev.confidence is not none %} ({{ ev.confidence }}%){% endif %}
          </li>
        {% endfor %}
      </ul>
    {% else %}
      <div class="small">
        No events yet in this entry. Build one on the left, click <strong>+ Add Event Details</strong>, then save.
        You can add multiple rows before saving.
      </div>
    {% endif %}

    <div style="margin-top:12px">
      <a class="btn outline" target="_top"
         href="{{ url_for('general_iframe_wizard', type=type_name, bio_id=bio_id, step='review') }}">Skip to Review</a>
    </div>
  </div>
</div>
  </div>
</div>
</body>
</html>